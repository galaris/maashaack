# Object Definitions #

<a href='http://creativecommons.org/licenses/by-sa/3.0/'><img src='http://i.creativecommons.org/l/by-sa/2.0/uk/88x31.png' alt='Licence Creative Commons' /></a> author : Marc ALCARAZ ([ekameleon](https://code.google.com/u/109962507657971592081/))



The **IoC** container is initialized with object definitions that are "operating instructions" for creating objects in an application. They also define dependency relationships that can have objects and classes with each other.

The **object definitions** are represented by objects that implement the interface **system.ioc.IObjectDefinition**, this interface is implemented by the class **ObjectDefinition**.

The **IObjectDefinition** interface has the following characteristics :
  * A unique identifier for each object definition (required).
  * A description of the type of object that will be returned or created with the object definition (required).
  * References to the "dependencies" of the object.
  * All the elements that will initialize the object at the time of its creation.
  * All the elements that will control the behavior of an object in the application : its scope, its methods invoked throughout its life cycle, etc.

The concepts listed above correspond to a set of elements in simple **generic objects** that create and initialize the **object definitions** from an **IoC** container.

**usage**

```
ObjectDefinition.create( init:Object ):ObjectDefinition
```

The **system.ioc.!ObjectDefinition** class contains a static method "create" who generate a new instance very simply by switching to a **generic object** parameter initialization compatible with the attributes to be defined next in its chapter.

It will always be easier to use the static **create()** method to initialize by hand all **ObjectDefinition** instances in your applications.

**example**

```
import flash.text.TextField ;
import flash.text.TextFormat ;

import system.ioc.ObjectDefinition ;

var context:Object =
{
    id         : "my_field" ,
    type       : "flash.text.TextField" ,
    properties :
    [
        { name : "defaultTextFormat" , value : new TextFormat("verdana", 11) } ,
        { name : "selectable"        , value : false                         } ,
        { name : "text"              , value : "hello world"                 } ,
        { name : "textColor"         , value : 0xF7F744                      } ,
        { name : "x"                 , value : 100                           } ,
        { name : "y"                 , value : 100                           }
    ]
}

var definition:ObjectDefinition = ObjectDefinition.create( context ) ;

trace( "definition.id              : " + definition.id ) ;
trace( "definition.getType()       : " + definition.getType() ) ;
trace( "definition.getScope()      : " + definition.getScope() ) ;
trace( "definition.isSingleton()   : " + definition.isSingleton() ) ;
trace( "definition.isLazyInit()    : " + definition.isLazyInit() ) ;
trace( "definition.getProperties() : " + definition.getProperties() ) ;
```

The **generic object** used to initialize the object definition contains specific attributes. We will discuss later in this chapter about these attributes by dividing them into four distinct groups.

**[1 - Basic attributes to create an object definition](object_definitions_basic_attributes.md)**

| **id** (required) | The unique identifier of the object definition. This identifier is a key used to find the reference of the corresponding object in the IoC container. |
|:------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------|
| **type** (required) | The full name of the type(class) of the object created and returned by the factory.                                                                   |
| **arguments**     | A list (Array) of all the arguments in the constructor of the class or also in the methods invoked to initialize the new object.                      |
| **properties**    | A list (Array) of all properties initialized after the creation of the object.                                                                        |
| **singleton**     | Defines soon the scope "singleton" of the object generated by the factory.                                                                            |
| **scope**         | Defines exactly the scope of the new object generated by the factory : "prototype" or "singleton".                                                    |
| **lazyInit**      | In general all "**singleton**" objects are initialized at startup in the factory. To stop such unnecessary initialization we use lazy initialization which create the **singletons** when it if first requested. |

**2 - Lifecycle of the objects defined and created with an object definition**

| **identify** | Can identify some Identifiable objects by assigning them automatically the id value of the object definition. |
|:-------------|:--------------------------------------------------------------------------------------------------------------|
| **lock**     | Active the lock process during the initialization of an object created by the factory. The object implements the system.process.Lockable interface. |
| **init**     | Indicates the name of the method to call to finish to initialize the object.                                  |
| **destroy**  | Indicates the name of the method to call to destroy a singleton object register in the IoC container.         |
| **dependsOn** | A list (Array) of objects identifiers registered in the factory who must exist before the current object is generated and initialized. |
| **generates** | A list (Array) of objects identifiers registered in the factory who must exist after the current object is generated and initialized. |
| **listeners** | A list (Array) of event listeners to register with the current dispatcher object (the object must implement the flash.events.IEventDispatcher interface) |
| **receivers** | A list (Array) of signals to connect with the object (if the object implements the system.signals.Receiver interface) or one or more of this methods (slots).|

**3 - The different strategies in the factory to create or target objects**

| **factoryMethod** | Creates an object with a method defines over a reference defines in the factory with a specific object definition. |
|:------------------|:-------------------------------------------------------------------------------------------------------------------|
| **factoryProperty** | Creates an object with a simple attribute defines over a reference defines in the factory with a specific object definition. |
| **factoryReference** | Target an object definition already defined in the factory to generate a new object or modify the existing object. |
| **factoryValue**  | Allows you to use any value defined directly in the external environment of the factory as a reference in an object definition. |
| **staticFactoryMethod** | Creates an object using a static method defines in a class of the application.                                     |
| **staticFactoryProperty** | Creates an object using a static attribute defines in a class of the application.                                  |

**4 - The "evaluators" attribute**

| **evaluators** | You can use this attribute to filter or transform the values defines in the the attributes "properties" and "arguments". |
|:---------------|:-------------------------------------------------------------------------------------------------------------------------|

We will define for the rest of the chapter a basic example that illustrate the techniques to define a collection (**Array**) of **generic objects** used to initialize and fill the factory.

This collection can then be stored in an external text file format like eden or directly in the source code of the **ActionScript** application.

Take the time to create a small **examples.core.User** class to illustrate the dependencies that can have a class with other classes.

```
package examples.core
{  
    public class User
    {
        public function User
        ( 
            pseudo:String   = null , 
            name:String     = null , 
            address:Address = null 
        )
        {
            this.pseudo  = pseudo ;
            this.name    = name ;
            this.address = address ;
        }
      
        public var address:Address ;
        
        public var age:Number ;
        
        public var firstName:String ;
        
        public var job:Job ;
        
        public var mail:String ;
        
        public var name:String ;
        
        public var pseudo:String ;
        
        public var url:String ;
        
        public function destroy():void
        {
            trace( this + " destroy.") ;
        }
        
        public function initialize():void
        {
            trace( this + " initialize.") ;
        }
        
        public function setMail( str:String ):void
        {
            mail = str ;
        }
        
        public override function toString():String
        {
            return "[User" + pseudo + "]" ;
        }
    }
}
```

We observe in the **User** class notions of dependencies explained in the previous chapter in terms of its **constructor** function, its **attributes** and **methods**.

The **User** class has many dependencies, for example with the **Address** and **Job** classes defined below :

**examples.core.Address :**

```
package examples.core
{
    public class Address
    {
        public function Address
        ( 
            city:String   = null , 
            street:String = null , 
            zip:Number    = NaN 
        )
        {
            this.city   = city ;
            this.street = street ;
            this.zip    = zip	;
        }
        
        public var city:String ;
        public var street:String ; 
        public var zip:Number ;
    }
}
```

**examples.core.Job :**

```
package examples.core
{   
    public class Job
    {
        public function Job( name:String = null )
        {
            this.name = name ;
        }
        
        public var name:String ;
        
        public function toString():String
        {
            return "[Job " + name + "]" ;
        }
    }
}
```

Now let's see an example of **IoC** configuration containing all the **object definitions** which will then used in the lightweight container and to create an instance of the **examples.core.User** class :

```
var objects:Array =
[
    {  
        id        	: "address"  ,
        type      	: "examples.core.Address" ,
        properties	:
        [
            { name : "city"   , value : "Marseille" } ,
            { name : "street" , value : "xx xxx xxxxxxxxxxx" } ,
            { name : "zip"    , value : 13001 }
        ]
    }
    ,
    {  
        id     	: "job_dev"   ,
        type   	: "examples.core.Job"  ,
        scope  	: "prototype" ,
        properties : [ { name:"name" , value:"AS Developper" } ]
    }   
    ,
    { 
        id         : "user" ,
        type       : "examples.core.User" ,
        arguments :
        [
            { value : "eKameleon" } ,
            { value : "ALCARAZ"   } ,
            { ref   : "address"   }
        ] ,
        lazyInit   : true , 
        singleton  : true ,
        destroy    : "destroy" ,
        init       : "initialize" ,
        properties :
        [
            { name : "age"       , value : 32        } ,
            { name : "firstName" , value : "Marc"    } ,
            { name : "job"       , ref   : "job_dev" } ,
            { name : "url"       , value : "http://www.ekameleon.net" } ,
            { 
                name : "setMail" , 
                arguments : [ { value : "ekameleon [at] gmail.com" } ] 
            }
        ]
    }
] ;
```

The above example does not use all the attributes defined at the beginning of this chapter, but shows the most important features of an **object definition**.

It remains only to initialize the factory and retrieve the object defined in the factory with a basic **ActionScript** code :

```
import system.ioc.factory ;

import examples.core.User ;

factory.run( objects ) ;

var user:User = factory.getObject( "user" ) as User ;

trace( user ) ;
```

We will use much of this example in the descriptions of the attributes that follow.