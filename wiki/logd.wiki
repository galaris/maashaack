#summary logd library.

= About =

*logd* is a logging library implemented in the spirit of the *core* package,<br>
small, fast and without any dependencies.

<wiki:comment>
<a href="http://maashaack.googlecode.com"><img src="http://maashaack.googlecode.com/svn/gfx/download.png" align="left"/></a>
</wiki:comment>

|| *package* || *FPAPI* || *CC* || *dependencies* || *cross-platform* || *redtamarin* ||
|| `core.*` || FP_10_2<br>avmglue 0.1 || `LOG::P` (optional) || n/a || yes || 0.3.1 ||

|| *browse* || [http://code.google.com/p/maashaack/source/browse/#svn%2Flibraries%2Flogd%2Ftrunk /libraries/logd/trunk] ||
|| *checkout* || `svn checkout http://maashaack.googlecode.com/svn/libraries/logd/trunk logd-read-only` ||

<a href="http://maashaack.googlecode.com"><img src="http://maashaack.googlecode.com/svn/gfx/swc.png" align="left"/></a>
<a href="http://maashaack.googlecode.com"><img src="http://maashaack.googlecode.com/svn/gfx/abc.png" align="left"/></a>

<br>
<br>
<br>
<br>

= Introduction =

Today in AS3 you must have about 100's of different logging libraries,<br>
people kind of followed what happened with Java<br>
(Log4J, Jakarta Commons-Logging, SLF4J, java.util.logging, etc.).

No seriously, search google code for "as3 logging" and [http://code.google.com/hosting/search?q=as3+logging see for yourself].

One thing for sure is that to log information is something useful,<br>
but because there are so many different logging implementations in AS3<br>
you don't want to impose the use of one particular logging library (simply because you use it in your code).

In the *maashaack framework* there is a fairly complete logging library *system.logging*<br>
you can browse the code here [http://code.google.com/p/maashaack/source/browse/#svn%2Ftrunk%2FAS3%2Fsrc%2Fsystem%2Flogging /trunk/AS3/src/system/logging]

But this *system.logging* is more something that someone would use in his/her application code,<br>
and something we try to not use in the lower layers of packages,libraries etc.
<br>
<br>

= Details =

*logd* focus on 3 points
 * being as small and fast as possible
 * being customisable so you can hook it with any other logging library
 * being completely removable with ConditionalCompilation

Also *logd* has been largely inspired by [http://developer.android.com/reference/android/util/Log.html android.util.Log].

You could resume *logd* as a wrapper around `trace()` that connect its input/output to other loggers.

here the API
{{{
package core
{
    public interface Logger
    {
        function get SUPPRESS():int;
        function get VERBOSE():int;
        function get DEBUG():int;
        function get INFO():int;
        function get WARN():int;
        function get ERROR():int;
        function get ASSERT():int;
        
        function get id():String;

        function get level():int;
        function set level( value:int ):void;
        
        function get input():Function;
        function set input( value:Function ):void;
        
        function get output():Function;
        function set output( value:Function ):void;

        function config( cfg:Object ):void;

        function format( priority:int, pre:String = "", post:String = "" ):void;

        function tag( name:String, level:int = -1 ):Logger;

        function v( msg:String, o:* = null ):void;
        function d( msg:String, o:* = null ):void;
        function i( msg:String, o:* = null ):void;
        function w( msg:String, o:* = null ):void;
        function e( msg:String, o:* = null ):void;
        function wtf( msg:String, o:* = null ):void;

        function println( priority:int, tag:String, msg:String, o:* = null ):void;        
    }
}
}}}
<br>
<br>

to remove any *logd* calls enclose them with `LOG::P` and see ConditionalCompilation

{{{

public function test()
{
    LOG::P { log.d( "debug some stuff" ); }
    //code
}

}}}
<br>
<br>


----
= Documentation =

*logd* can use 4 different mode

*raw* for text file<br>
`ID | PRIORITY LETTER | TAG | MESSAGE | TIME`
 * *ID* is a random hex of 8 chars
 * *PRIORITY LETTER*
    * *V* for verbose
    * *D* for debug
    * *I* for info
    * *W* for warn
    * *E* for error
    * *WTF* for a fatal error
 * *TAG* a custom tag or the empty string by default
 * *MESSAGE* the log message
 * *TIME* timestamp in milliseconds

*clean* for console output<br>
`TAG | PRE | MESSAGE | POST | TIME`
 * *TAG* a custom tag or the empty string by default
 * *PRE* pre priority format
 * *MESSAGE* the log message
 * *POST* post priority format
 * *TIME* timestamp in milliseconds

*data* for advanced custom output<br>
there is not a formated output, but a data structure meant<br>
to be formated by your own custom output function
{{{
obj
{
    id: "17AC06D37",
    priority: 4,
    letter: "I",
    pre: "( ",
    post: " )",
    tag: "",
    time: 63,
    sep: "|",
    o: null
}
}}}
 * *id* (string): session id
 * *priority* (int): priority number
 * *letter* (string): priority letter
 * *pre* (string): pre priority format
 * *post* (string): post priority format
 * *tag* (string): custom tag
 * *time* (uint): timestamp
 * *sep* (string): separator
 * *o*: custom object

*short* for text field<br>
`MESSAGE`
and nothing else unless you customize the input/output.

<br>
<br>

== Constants ==

=== SUPPRESS ===
{{{
function get SUPPRESS():int;
}}}
SUPPRESS value.
<br>
<br>

=== VERBOSE ===
{{{
function get VERBOSE():int;
}}}
VERBOSE value.
<br>
<br>

=== DEBUG ===
{{{
function get DEBUG():int;
}}}
DEBUG value.
<br>
<br>

=== INFO ===
{{{
function get INFO():int;
}}}
INFO value.
<br>
<br>

=== WARN ===
{{{
function get WARN():int;
}}}
WARN value.
<br>
<br>

=== ERROR ===
{{{
function get ERROR():int;
}}}
ERROR value.
<br>
<br>

=== ASSERT ===
{{{
function get ASSERT():int;
}}}
ASSERT value.
<br>
<br>

== Properties ==

=== id ===
{{{
function get id():String
}}}
Returns the unique ID for the logger.
<br>
<br>

=== level ===
{{{
function get level():int
function set level( value:int ):void
}}}
Sets/Returns the logging level for this logger.
<br>
<br>

=== input ===
{{{
function get input():Function
function set input( value:Function ):void
}}}
Define a log input function.

The input is used to parse the log before sending it,<br>
you could use it to support special formating, appending<br>
additional informations, etc.

the function HAVE TO respect this signature
{{{
function input( msg:String, o:* = null ):Object
{
    //your code
}
}}}
The returned object must contains 2 properties `msg` and `o`.
<br>
<br>

=== output ===
{{{
function get output():Function
function set output( value:Function ):void
}}}
Define a log output function.

The output is used to send the log to a destination,<br>
by default we use `trace()` but you could<br>
use Socket, LocalConnection, etc.

the function HAVE TO respect this signature
{{{
function output( msg:String, o:* = null ):String
{
    //your code
}
}}}
<br>
<br>


== Methods ==

=== config ===
{{{
function config( cfg:Object ):void
}}}
Configure the logger with values/pairs.

*example*:
{{{
cfg = { sep: " ", //char separator
             mode: "raw", // "clean", "data", "short"
             tag: true, //use tag
             time: false  //use time
          }
log.config( cfg );
}}}
<br>
<br>

=== format ===
{{{
function format( priority:int, pre:String = "", post:String = "" ):void
}}}
Changes the formatting of the passed priority.

*example*:
{{{
log.config( { mode: "clean" } );
log.format( log.DEBUG, "D{ ", " }" );
log.d( "hello world" ); // D{ hello world }
}}}
<br>
<br>

=== tag ===
{{{
function tag( name:String, level:int = -1 ):Logger
}}}
Creates a tag and return a new logger object.

*note:*<br>
The default implementation does not provide a `tag` (eg. it's the empty string).<br>
A tag can be anything from a simple name to the full path of your class, etc.<br>

*example*:
{{{
var mylog:Logger = log.tag( "socket" );
mylog.d( "client connected" ); // D|socket|client connected
}}}
<br>
<br>

=== v ===
{{{
function v( msg:String, o:* = null ):void
}}}
Send a VERBOSE log message.
<br>
<br>

=== d ===
{{{
function d( msg:String, o:* = null ):void
}}}
Send a DEBUG log message.
<br>
<br>

=== i ===
{{{
function i( msg:String, o:* = null ):void
}}}
Send an INFO log message.
<br>
<br>

=== w ===
{{{
function w( msg:String, o:* = null ):void
}}}
Send a WARN log message.
<br>
<br>

=== e ===
{{{
function e( msg:String, o:* = null ):void
}}}
Send an ERROR log message.
<br>
<br>

=== wtf ===
{{{
function wtf( msg:String, o:* = null ):void
}}}
What a Terrible Failure (or What The Fuck).<br>
Report a condition that should never happen (eg. send an ASSERT log message).
<br>
<br>

=== println ===
{{{
function println( priority:int, tag:String, msg:String, o:* = null ):void
}}}
Low-level logging call.
<br>
<br>

----

= Usages =

== import and log and that's it ==
{{{
package test
{
    import core.log;

    public class MyClass
    {
        public function MyClass()
        {
            log.i( "constructor" );
        }

        public function toString():String
        {
            log.i( "toString" );
            return "MyClass";
        }
    }
}

//output (by default with trace() and flashlogs.txt
17AC06D37|I||constructor|64
17AC06D37|I||toString|65
}}}

This format is the *raw* mode, when you mainly target a text file to store your logs.

the `17AC06D37` is the id for the logging session and is here only to be able to<br>
filter the logs from a big text file (like `flashlogs.txt`) and get the particular session.
<br>
<br>

== Adding a custom tag ==
{{{
package test
{
    import core.log;
    import core.Logger;

    public class MyClass
    {
        private var _log:Logger;

        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.i( "constructor" );
        }

        public function toString():String
        {
            _log.i( "toString" );
            return "MyClass";
        }
    }
}

//output
17AC06D37|I|MyClass|constructor|64
17AC06D37|I|MyClass|toString|65
}}}
<br>

== Change the mode and the separator ==
{{{
package test
{
    import core.log;
    import core.Logger;

    public class MyClass
    {
        private var _log:Logger;

        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.config( { mode: "clean", sep: " " } );
            _log.i( "constructor" );
        }

        public function toString():String
        {
            _log.i( "toString" );
            return "MyClass";
        }
    }
}

//output
MyClass ( constructor ) 64
MyClass ( toString ) 65
}}}
<br>

== Change the format for a particular priority and change the logging level (and all of the above) ==
{{{
package test
{
    import core.Logger;
    import core.log;
    
    public class MyClass
    {
        private var _log:Logger;
        
        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.level = log.VERBOSE;
            _log.config( { mode: "clean", sep: " " } );
            _log.format( log.DEBUG, "|---------> ", "" );
            _log.i( "constructor" );
        }
        
        public function test():void
        {
            _log.d( "test" );
        }
        
        public function toString():String
        {
            _log.i( "toString" );
            return "MyClass";
        }
    }
}
//output
MyClass ( constructor ) 64
MyClass |---------> test 65
MyClass ( toString ) 65
}}}
<br>

== Customize the input function ==
{{{
package test
{
    import core.Logger;
    import core.log;
    
    public class MyClass
    {
        private var _log:Logger;
        
        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.level = log.VERBOSE;
            _log.config( { mode: "clean", sep: " " } );
            _log.input = custom_input;
            _log.i( "constructor: {0} {1}", [ "hello", "world" ] );
        }
        
        private function custom_input( msg:String, o:* = null ):Object
        {
            if( o )
            {
                msg = fastformat( msg, o );
                o   = null;
            }
            
            return { msg: msg, o: o };
        }
        
        public function fastformat( pattern:String , ...args:Array ):String
        {
            if( (pattern == null) || (pattern == "") )
            {
                return "";
            }
            
            var len:int = args.length;
            
            if( (len == 1) && (args[0] is Array) )
            {
                args = args[0] ;
                len  = args.length;
            }
            
            for( var i:int=0; i < len; i++ )
            {
                pattern = pattern.replace( new RegExp( "\\{"+i+"\\}", "g" ), args[i] );
            }
            
            return pattern;
        }
        
        public function test():void
        {
            _log.d( "test {0}+{1}={2}", [2,5,7] );
        }
        
        public function toString():String
        {
            _log.i( "toString{0}", "()" );
            return "MyClass";
        }
    }
}

//output
yClass ( constructor: hello world ) 64
MyClass [ test 2+5=7 ] 65
MyClass ( toString() ) 65
}}}
<br>

== Customize the output function ==
{{{
package test
{
    import core.Logger;
    import core.log;
    
    import flash.external.ExternalInterface;
    
    public class MyClass
    {
        private var _log:Logger;
        
        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.level = log.VERBOSE;
            _log.config( { mode: "clean", sep: " " } );
            _log.output = custom_output;
            _log.i( "constructor" );
        }
        
        private function custom_output( msg:String, o:* = null ):void
        {
            //basic firebug hook
            if( ExternalInterface.available )
            {
                ExternalInterface.call( "console.log", msg );
            }
        }
        
        public function test():void
        {
            _log.d( "test" );
        }
        
        public function toString():String
        {
            _log.i( "toString" );
            return "MyClass";
        }
    }
}

//output is forwarded to another logger
}}}
here any log message will be redirected to the firebug command `console.log()`.
<br>
<br>

== Advanced customization of the output function with mode 'data' ==
{{{
package test
{
    import core.Logger;
    import core.log;
    
    import flash.external.ExternalInterface;
    
    public class MyClass
    {
        private var _log:Logger;
        
        public function MyClass()
        {
            _log = log.tag( "MyClass" );
            _log.level = log.VERBOSE;
            _log.config( { mode: "data", sep: " " } );
            _log.output = custom_output;
            _log.i( "constructor" );
        }
        
        private function custom_output( msg:String, o:* = null ):void
        {
            var command:String;
            
            //advanced firebug hook
            switch( o.priority )
            {
                case log.DEBUG:
                command = "console.debug";
                break;
                
                case log.INFO:
                command = "console.info";
                break;
                
                case log.WARN:
                command = "console.warn";
                break;
                
                case log.ERROR:
                command = "console.error";
                break;
                
                case log.ASSERT:
                command = "console.assert";
                break;
                
                case log.VERBOSE:
                default:
                command = "console.log";
            }
            
            if( ExternalInterface.available )
            {
                ExternalInterface.call( command, msg );
            }
        }
        
        public function test():void
        {
            _log.d( "test" );
        }
        
        public function toString():String
        {
            _log.i( "toString" );
            return "MyClass";
        }
    }
}

//output is forwarded to another logger
}}}

here the log message will be redirected to the corresponding firebug command<br>
the *data* mode allow us to switch on the `o.priority`<br>
`log.d( "debug infos" )` will redirect to `console.debug()`<br>
`log.i( "infos" )` will redirect to `console.info()`<br>
etc.